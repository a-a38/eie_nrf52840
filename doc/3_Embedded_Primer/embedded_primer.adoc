= Embedded Primer
:doctype: article
:imagesdir: imgs
:toc:

== Introduction
This lesson is a primer on working with embedded systems and the Zephyr RTOS.
Our goal is to complete the "Hello World" of embedded systems, blinking an LED from scratch.

=== What is an Embedded System?
Embedded systems are a small computer system that serves a specific purpose as part of a larger system.
Typically they will have limited resources such as memory and program size.
Most embedded systems use a microcontroller which is a type of microprocessor that includes integrated memory and peripherals on a single chip.
We will be using the nRF52840 microcontroller in this course on the nRF52840 Development Kit provided by Nordic Semiconductor.

.The nRF52840 Processor Block Diagram. Source Nordic Semiconductor <<nordic-block>>
[]
image::https://docs-be.nordicsemi.com/bundle/ps_nrf52840/page/chapters/blockdiagram/doc/image/block.nrf52840.svg[]

=== General Purpose Input Output (GPIO)
The General Purpose Input Output (GPIO) peripheral is one of the most common peripherals found on a microcontroller.
It provides a way to read and write digital signals to and from the physical pins on the microcontroller.
A pin controlled by the GPIO peripheral is referred to as a GPIO pin.
These pins can be used to read a button, turn on an LED, control enable lines for other chips, and much more.

To use one of the GPIO pins we first need to configure it.
Configuring the pin typically involves setting various registers (Registers are a logic circuit that store a value).
The GPIO pin configuration circuitry for the nRF52840 is shown below.

.nRF52840 GPIO Pin Configuration Block Diagram. Source Nordic Semiconductor <<nordic-gpio>>
[]
image::https://docs-be.nordicsemi.com/bundle/ps_nrf52840/page/ip/gpio/doc/image/block.svg[]

Each line coming into the configuration block represents the output of a bit from one of the control registers.
Each register is mapped to an address in the microcontroller allowing the developer to read and write to the register using pointers.

=== Zephyr RTOS
When working with embedded systems we generally have two options for writing software.

1. Write software that directly accesses the hardware registers to control the peripherals.
2. Use a hardware abstraction layer (HAL) to abstract the low level details of the hardware.

In general using a HAL is preferred as it makes the code easier to read, maintain, and port to other hardware.
Zephyr provides a HAL and a real time operating system (RTOS) for the nRF52840 and many other microcontrollers that makes working with this hardware easier.

==== Hardware Abstraction via the Device Tree
The Zephyr project uses a data structure called a device tree to describe the microcontroller and the board it is on.
The microcontroller device tree definition file defines all the peripherals in the microcontroller and the addresses of the registers to control them.
The board device tree definition file describes how the microcontroller is connected to other components on the board such as LEDs, buttons, or sensors and what peripherals on the microcontroller they are connected to.
We won't cover too much about the device tree but more information can be found in the Zephyr documentation.
https://docs.zephyrproject.org/latest/build/dts/index.html

Additionally Nordic's DevAcadamy introductory course on the nRF Connect SDK covers the device tree in more detail in link:https://academy.nordicsemi.com/courses/nrf-connect-sdk-fundamentals/lessons/lesson-3-elements-of-an-nrf-connect-sdk-application/topic/configuration-files/[Lesson 3].

== Lesson

=== Project Configuration

. Check out the `embedded_primer` branch:
+
----
git fetch upstream
git checkout embedded_primer
----
. In the `app/src` directory, create a new `main.c` file
. KConfig is a configuration system originally developed for linux kernel development.
It allows developers to set configuration options for their application that are set at compile time.
In Zephyr these options are used to enable or disable features in the kernal and enable specific libraries.
+
For now we need to enable the GPIO library in our application so that we can use it to control the LED.
Open the `app/prj.conf` file in your editor.
We want to add a line to enable GPIO support in the application
+
image::prj_edits.png[]
Nordic's DevAcadamy course on nRF Connect SDK fundamentals covers more on kConfig including adding your own configuration options in link:https://academy.nordicsemi.com/courses/nrf-connect-sdk-fundamentals/lessons/lesson-3-elements-of-an-nrf-connect-sdk-application/topic/exercise-2/[Exercise 2 of Lesson 3].
. CMake is a meta-build tool; That is it doesn't compile source files on its own but rather tells other tools what to build.
In our case CMake pulls in the list of source file from the `CMakeLists.txt` file, the project configuration via the kConfig file `prj.conf` and the device tree files which describe the board and its peripherals.
It then generates files used by the ninja build system which uses the GNU toolchain to compile the application.
+
.The Zephyr build process. Source Nordic Semiconductor <<nordic-build-system>>
[]
image::https://docs-be.nordicsemi.com/bundle/ncs-latest/page/nrf/_images/ncs-toolchain.svg[]
+
Open the `app/CMakeLists.txt` file in your editor.
We need to add the `main.c` file to the `CMakeLists.txt` file so that CMake knows where our source code is.
In the future if we add more source files we will need to add them here as well.
Add the following line to the `CMakeLists.txt` file:
+
image::cmake_edits.png[]
. Add the files modified to the git staging area and commit the changes.
+
----
git add app/CMakeLists.txt app/prj.conf app/src/main.c
git commit -m "Setup project configuration"
----

=== Let's Blink an LED
. To start with we need to add some bare minimum code to our `main.c` file.
We need to include the Zephyr header files we are going to use and define the main function.
In the main function we will create an infinite while loop where our code will run.
This is a common pattern in embedded systems where there is no operating system to return to, so the application runs forever and main never returns.
+
image::minimum_main.png[]
At this point the application should build but won't do anything.
+
----
west build -b nrf52840dk/nrf52840 app
----
.. If the build is successful add the main.c file to the git staging area and commit the change. Use a commit message like "Add minimum main function".
. Now we need to define which pin is connected to the LED.
To do this first we need to get the LED pin configuration and fill our the zephyr GPIO device tree specification struct.
+
image::dev_tree_gpio_struct.png[]
This struct defines the GPIO pin using the port the pin is on, the pin number and a flag field.
Most microcontrollers split their GPIO pins into multiple ports; The pins on each port typically are accessed through a single register.
The nRF52840 has 2 ports, port 0 and 1 each of which have a set of pins.
For our purposes, Zephyr abstracts this using the device tree.
The device tree configuration for the nRF52840DK specifies the port and pin number for each of the LEDs on the board.
We can then use the Zephyr `DT_ALIAS` and `GPIO_DT_SPEC_GET` macros to create the pin object for the LED we want to use.
+
image::pin_macros.png[]
. Next we need to initialize the GPIO pin and configure it to be an output pin.
First we need to check that the gpio struct we created is ready to use which we can do using the `gpio_is_ready_dt` function.
Then we can use the `gpio_pin_configure_dt` function which takes a pointer to the GPIO struct we made in the last step and a flag that will configure the pin mode.
Zephyr defines the following macros that we can use to set the pin mode:
* `GPIO_INPUT`: Configure the pin as an input. This will come up next week when we talk about buttons.
* `GPIO_OUTPUT`: Configure the pin as an output
* `GPIO_OUTPUT_ACTIVE`: Configure the pin as an output and set it to high
* `GPIO_OUTPUT_INACTIVE`: Configure the pin as an output and set it to low
In our case we will want to configure the LED as an output and set it high; this setting starts the LED off since the nRF52840DK uses active low LEDs.
In the end we should end up with code that looks like this that initializes the LED pin
+
image::pin_init.png[]
. Add your changes to the main.c file and commit them to git with a message like "Initialize LED pin".
. Now we need to make the LED blink.
There is a few zephyr APIs we can use to control the GPIO pin.
* `gpio_pin_set_dt`: This function takes a pointer to the GPIO struct and a value of 0 or 1 and sets the pin low or high respectively.
* `gpio_pin_toggle_dt`: This function takes a pointer to the GPIO struct and toggles the pin state from high to low or low to high.
In our case we will use the toggle function to blink the LED inside the while loop.
+
image::led_toggle.png[]
At this point you should be able to build the application and flash it to the board and the LED should blink.
----
west build -b nrf52840dk/nrf52840 app
west flash
----

=== Why is my LED not blinking?

. Let's look at the LED pin on an oscilloscope.
+
image::led_scope.png[]
We can see that the LED is blinking, but it is turning on and off every 500 nanoseconds!
This is far faster than we are able to see with our eyes.
. To fix this we need to add a delay between toggling the LED pin.
For this lesson we will use the zephyr `k_sleepms` function which puts the processor to sleep for a specified number of milliseconds.
In general in embedded systems we want the processor to be asleep as much as possible to save power.
After adding the delay the code should look like this and the LED should blink.
image::complete_main.png[]
. Now we can build and flash the application to the board again and the LED should blink once per second.
+
----
west build -b nrf52840dk/nrf52840 app
west flash
----
. Add your changes to the main.c file and commit them to git with a message like "Make LED blink".

== Exercise

Now that we have gotten one LED to blink on your own try the following:

* Make the other 3 LEDs blink.
* Make one LED blink twice as fast as the others.
* Make the LEDs blink in a sequence. (Example have the 4 LEDs turn on one at a time in a loop)

Create a separate commit for each part of the exercise you complete. When you are done push your changes to your copy of the repository on GitHub.
----
git push origin embedded_primer
----




[bibliography]
== References

* [[[nordic-block, 1]]] Nordic Semiconductor. _Block Diagram._ [Online]. Available: https://docs.nordicsemi.com/bundle/ps_nrf52840/page/blockdiagram.html
* [[[nordic-gpio, 2]]] Nordic Semiconductor. _GPIO - General purpose input/output._ [Online]. Available: https://docs.nordicsemi.com/bundle/ps_nrf52840/page/gpio.html
* [[[nordic-build-system, 3]]] Nordic Semiconductor. _Build and Configuration System._ [Online]. Available: https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/config_and_build_system.html