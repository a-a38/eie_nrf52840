= Embedded Primer
:doctype: article
:imagesdir: imgs

:toc:


== Lesson

=== Project Configuration

. Check out the `embedded_primer` branch:
+
----
git fetch upstream
git checkout embedded_primer
----
. In the `app/src` directory, create a new `main.c` file
. KConfig is a configuration system originally developed for linux kernel development.
It allows developers to set configuration options for their application that are set at compile time.
In Zephyr these options are used to enable or disable features in the kernal and enable specific libraries.
+
For now we need to enable the GPIO library in our application so that we can use it to control the LED.
Open the `app/prj.conf` file in your editor.
We want to add a line to enable GPIO support in the application
+
image::prj_edits.png[]
Nordic's DevAcadamy course on nRF Connect SDK fundamentals has
. CMake is a meta-build tool; That is it doesn't compile source files on its own but rather tells other tools what to build.
In our case CMake pulls in the list of source file from the `CMakeLists.txt` file, the project configuration via the kConfig file `prj.conf` and the device tree files which describe the board and its peripherals.
It then generates files used by the ninja build system which uses the GNU toolchain to compile the application.
+
.The Zephyr build process. Source Nordic Semiconductor <<nordic-build-system>>
[]
image::https://docs-be.nordicsemi.com/bundle/ncs-latest/page/nrf/_images/ncs-toolchain.svg[]
+
Open the `app/CMakeLists.txt` file in your editor.
We need to add the `main.c` file to the `CMakeLists.txt` file so that CMake knows where our source code is.
In the future if we add more source files we will need to add them here as well.
Add the following line to the `CMakeLists.txt` file:
+
image::cmake_edits.png[]
. Add the files modified to the git staging area and commit the changes.
+
----
git add app/CMakeLists.txt app/prj.conf app/src/main.c
git commit -m "Setup project configuration"
----

=== Let's Blink an LED
. To start with we need to add some bare minimum code to our `main.c` file.
We need to include the Zephyr header files we are going to use and define the main function.
In the main function we will create an infinite while loop where our code will run.
This is a common pattern in embedded systems where there is no operating system to return to, so the application runs forever and main never returns.
+
image::minimum_main.png[]
At this point the application should build but won't do anything.
+
----
west build -b nrf52840dk/nrf52840 app
----
.. If the build is successful add the main.c file to the git staging area and commit the change. Use a commit message like "Add minimum main function".
. Now we need to define which pin is connected to the LED.
To do this first we need to get the LED pin configuration and fill our the zephyr GPIO device tree specification struct.
+
image::dev_tree_gpio_struct.png[]
This struct defines the GPIO pin using the port the pin is on, the pin number and a flag field.
Most microcontrollers split their GPIO pins into multiple ports; The pins on each port typically are accessed through a single register.
The nRF52840 has 2 ports, port 0 and 1 each of which have a set of pins.
For our purposes, Zephyr abstracts this using the device tree.
The device tree configuration for the nRF52840DK specifies the port and pin number for each of the LEDs on the board.
We can then use the Zephyr `DT_ALIAS` and `GPIO_DT_SPEC_GET` macros to create the pin object for the LED we want to use.
+
image::pin_macros.png[]
. Next we need to initialize the GPIO pin and configure it to be an output pin.
First we need to check that the gpio struct we created is ready to use which we can do using the `gpio_is_ready_dt` function.
Then we can use the `gpio_pin_configure_dt` function which takes a pointer to the GPIO struct we made in the last step and a flag that will configure the pin mode.
Zephyr defines the following macros that we can use to set the pin mode:
* `GPIO_INPUT`: Configure the pin as an input. This will come up next week when we talk about buttons.
* `GPIO_OUTPUT`: Configure the pin as an output
* `GPIO_OUTPUT_ACTIVE`: Configure the pin as an output and set it to high
* `GPIO_OUTPUT_INACTIVE`: Configure the pin as an output and set it to low
In our case we will want to configure the LED as an output and set it high; this setting starts the LED off since the nRF52840DK uses active low LEDs.
In the end we should end up with code that looks like this that initializes the LED pin
+
image::pin_init.png[]
. Add your changes to the main.c file and commit them to git with a message like "Initialize LED pin".
. Now we need to make the LED blink.
There is a few zephyr APIs we can use to control the GPIO pin.
* `gpio_pin_set_dt`: This function takes a pointer to the GPIO struct and a value of 0 or 1 and sets the pin low or high respectively.
* `gpio_pin_toggle_dt`: This function takes a pointer to the GPIO struct and toggles the pin state from high to low or low to high.
In our case we will use the toggle function to blink the LED inside the while loop.
+
image::led_toggle.png[]
At this point you should be able to build the application and flash it to the board and the LED should blink.
----
west build -b nrf52840dk/nrf52840 app
west flash
----

=== Why is my LED not blinking?

. Let's look at the LED pin on an oscilloscope.
+
image::led_scope.png[]
We can see that the LED is blinking, but it is turning on and off every 500 nanoseconds!
This is far faster than we are able to see with our eyes.
. To fix this we need to add a delay between toggling the LED pin.
For this lesson we will use the zephyr `k_sleepms` function which puts the processor to sleep for a specified number of milliseconds.
In general in embedded systems we want the processor to be asleep as much as possible to save power.
After adding the delay the code should look like this and the LED should blink.
image::complete_main.png[]
. Now we can build and flash the application to the board again and the LED should blink once per second.
----
west build -b nrf52840dk/nrf52840 app
west flash
----
. Add your changes to the main.c file and commit them to git with a message like "Make LED blink".

== Exercise

Now that we have gotten one LED to blink on your own try the following:

* Make the other 3 LEDs blink.
* Make one LED blink twice as fast as the others.
* Make the LEDs blink in a sequence. (Example have the 4 LEDs turn on one at a time in a loop)

Create a separate commit for each part of the exercise you complete. When you are done push your changes to your copy of the repository on GitHub.
----
git push origin embedded_primer
----




[bibliography]
== References

* [[[nordic-build-system, 1]]] Nordic Semiconductor. _Build and Configuration System._ [Online]. Available: https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/config_and_build_system.html